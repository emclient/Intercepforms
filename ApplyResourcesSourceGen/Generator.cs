using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Net.Mime;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ApplyResourcesSourceGen
{
    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var resxFiles = context.AdditionalTextsProvider.Where(static af => af.Path.EndsWith(".resx")).Collect();

            var applyResourcesLocations = context.SyntaxProvider
                .CreateSyntaxProvider(predicate: (node, _) => node is InvocationExpressionSyntax, transform: SyntaxProviderLocationTransformer)
                .Where(x => x.Item1 is not null)
                .Collect();

            var locationsAndResxFiles = applyResourcesLocations.Combine(resxFiles);

            context.RegisterSourceOutput(source: locationsAndResxFiles, action: SourceOutputAction);
        }

        private static (Location, ITypeSymbol, string) SyntaxProviderLocationTransformer(GeneratorSyntaxContext context, CancellationToken ct)
        {
            // Only look into .Designer.cs files
            var location = context.Node.GetLocation();
            if (location.SourceTree is null || !location.SourceTree.FilePath.EndsWith(".Designer.cs", StringComparison.OrdinalIgnoreCase))
                return (null!, null!, null!);

            // Check we are inside InitializeComponent
            var containingMethodInfo = context.Node.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (!containingMethodInfo?.Identifier.Text.Equals("InitializeComponent") != false)
                return (null!, null!, null!);
            var containingMethodSymbol = context.SemanticModel.GetDeclaredSymbol(containingMethodInfo, ct);

            // Check this is call to ApplyResources
            var invocationExpression = (InvocationExpressionSyntax)context.Node;
            var invocationSymbol = context.SemanticModel.GetSymbolInfo(invocationExpression, ct);
            var applyResourcesMethod = context.SemanticModel.Compilation
                .GetTypeByMetadataName("System.ComponentModel.ComponentResourceManager")
                ?.GetMembers("ApplyResources")
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => m.Parameters.Length == 2);
            if (invocationSymbol.Symbol is not IMethodSymbol methodSymbol ||
                applyResourcesMethod is null ||
                !methodSymbol.Equals(applyResourcesMethod, SymbolEqualityComparer.Default))
                return (null!, null!, null!);

            // Extract objectName argument (assumes a constant string)
            if (invocationExpression.ArgumentList.Arguments[1].Expression is not LiteralExpressionSyntax literalExpressionSyntax)
                return (null!, null!, null!);
            string objectName = literalExpressionSyntax.Token.ValueText;

            ITypeSymbol objectType = context.SemanticModel.GetTypeInfo(invocationExpression.ArgumentList.Arguments[0].Expression, ct).Type;
            var memberAccessExpression = (MemberAccessExpressionSyntax)invocationExpression.Expression;

            return (memberAccessExpression.Name.GetLocation(), objectType, objectName);
        }

        private static void SourceOutputAction(SourceProductionContext context, (ImmutableArray<(Location, ITypeSymbol, string)> left, ImmutableArray<AdditionalText> right) locationsAndResxFiles)
        {
            var builder = new StringBuilder();

            builder.AppendLine(
            $$"""
            // <auto-generated/>

            namespace System.Runtime.CompilerServices
            {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file sealed class InterceptsLocationAttribute : Attribute
                {
                    public InterceptsLocationAttribute(string filePath, int line, int column)
                    {
                    }
                }
            }

            static class Intercepforms
            {
            """);

            int i = 1;
            foreach ((var location, var objectType, var objectName) in locationsAndResxFiles.left)
            {
                if (location.SourceTree is null)
                    continue;

                var resXFileName = location.SourceTree.FilePath.Substring(0, location.SourceTree.FilePath.Length - ".Designer.cs".Length) + ".resx";
                var resXFile = locationsAndResxFiles.right.FirstOrDefault(f => f.Path == resXFileName);
                if (resXFile == null)
                    continue;

                var lineSpan = location.GetLineSpan();

                builder.AppendLine("");
                builder.AppendLine($"""
                    [global::System.Runtime.CompilerServices.InterceptsLocation(@"{location.SourceTree.FilePath}", {lineSpan.StartLinePosition.Line + 1}, {lineSpan.StartLinePosition.Character + 1})]
                """);
                builder.AppendLine($"""
                    public static void ApplyResources{i}(this System.ComponentModel.ComponentResourceManager manager, object value, string objectName)
                    {"{"}
                        System.Diagnostics.Debug.WriteLine("ApplyResources{i} {objectType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}");
                        manager.ApplyResources(value, objectName);
                    {"}"}
                """);

                i++;
            }

            builder.AppendLine(
            $$"""
            }
            """);

            context.AddSource("ApplyResources.g.cs", builder.ToString());
        }
    }
}

