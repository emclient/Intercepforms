using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ApplyResourcesSourceGen
{
    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var applyResourcesLocations = context.SyntaxProvider
                .CreateSyntaxProvider(predicate: (node, _) => node is InvocationExpressionSyntax, transform: SyntaxProviderLocationTransformer)
                .Where(x => x.Item1 is not null)
                .Collect();

            context.RegisterSourceOutput(source: applyResourcesLocations, action: SourceOutputAction);
        }

        private static (Location, string, string) SyntaxProviderLocationTransformer(GeneratorSyntaxContext context, CancellationToken ct)
        {
            // Check we are inside InitializeComponent
            var containingMethodInfo = context.Node.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (!containingMethodInfo?.Identifier.Text.Equals("InitializeComponent") == true)
                return (null!, null!, null!);
            var containingMethodSymbol = context.SemanticModel.GetDeclaredSymbol(containingMethodInfo, ct);

            // Check this is call to ApplyResources
            var invocationExpression = (InvocationExpressionSyntax)context.Node;
            var invocationSymbol = context.SemanticModel.GetSymbolInfo(invocationExpression);
            var applyResourcesMethod = context.SemanticModel.Compilation
                .GetTypeByMetadataName("System.ComponentModel.ComponentResourceManager")
                ?.GetMembers("ApplyResources")
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => m.Parameters.Length == 2);
            if (invocationSymbol.Symbol is not IMethodSymbol methodSymbol ||
                applyResourcesMethod is null ||
                !methodSymbol.Equals(applyResourcesMethod, SymbolEqualityComparer.Default))
                return (null!, null!, null!);

            // Extract objectName argument (assumes a constant string)
            if (invocationExpression.ArgumentList.Arguments[1].Expression is not LiteralExpressionSyntax literalExpressionSyntax)
                return (null!, null!, null!);
            string objectName = literalExpressionSyntax.Token.ValueText;

            var symbolDisplayFormat = new SymbolDisplayFormat(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
            string fullTypeName = containingMethodSymbol.ContainingType.ToDisplayString(symbolDisplayFormat);
            var memberAccessExpression = (MemberAccessExpressionSyntax)invocationExpression.Expression;

            return (memberAccessExpression.Name.GetLocation(), fullTypeName, objectName);
        }

        private static void SourceOutputAction(SourceProductionContext context, ImmutableArray<(Location, string, string)> locationsAndParams)
        {
            var builder = new StringBuilder();

            builder.AppendLine(
            $$"""
            // <auto-generated/>

            namespace System.Runtime.CompilerServices
            {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file sealed class InterceptsLocationAttribute : Attribute
                {
                    public InterceptsLocationAttribute(string filePath, int line, int column)
                    {
                    }
                }
            }

            static class Intercepforms
            {
            """);

            int i = 1;
            foreach ((var location, var typeName, var objectName) in locationsAndParams)
            {
                if (location.SourceTree is null)
                    continue;

                var lineSpan = location.GetLineSpan();

                builder.AppendLine("");
                builder.AppendLine($"""
                    [global::System.Runtime.CompilerServices.InterceptsLocation(@"{location.SourceTree.FilePath}", {lineSpan.StartLinePosition.Line + 1}, {lineSpan.StartLinePosition.Character + 1})]
                """);
                builder.AppendLine($"""
                    public static void ApplyResources{i}(this System.ComponentModel.ComponentResourceManager manager, object value, string objectName)
                    {"{"}
                        System.Diagnostics.Debug.WriteLine("ApplyResources{i}");
                        manager.ApplyResources(value, objectName);
                    {"}"}
                """);

                i++;
            }

            builder.AppendLine(
            $$"""
            }
            """);

            context.AddSource("ApplyResources.g.cs", builder.ToString());
        }
    }
}

